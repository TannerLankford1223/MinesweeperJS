{"ast":null,"code":"const ROWS = 8;\nconst COLS = 9;\nconst MINES = 10;\n\nfunction CreateBoard() {\n  let board = [];\n  let mines = []; // let numMines = 10;\n  // let rows = 8;\n  // let cols = 9;\n\n  let emptySpaces = ROWS * COLS - MINES;\n\n  for (let x = 0; x < ROWS; x++) {\n    let subColumn = [];\n\n    for (let y = 0; y < COLS; y++) {\n      subColumn.push({\n        value: 0,\n        fired: false,\n        x: x,\n        y: y,\n        flagged: false,\n        bomb: false\n      });\n    }\n\n    board.push(subColumn);\n  } // Randomly assign bombs to the board\n\n\n  let mineCount = 0;\n\n  while (mineCount < MINES) {\n    let x = randomNum(ROWS);\n    let y = randomNum(COLS);\n\n    if (!board[x][y].bomb) {\n      board[x][y].bomb = true;\n      mines.push([x, y]);\n      mineCount++;\n    }\n  }\n\n  findAdjacentBombs(board);\n  return {\n    board,\n    mines,\n    emptySpaces\n  };\n}\n\n_c = CreateBoard;\n; // Iterate through cells and count the number of adjacent bombs, incrementing the value of the cell\n// if any are found\n\nfunction findAdjacentBombs(board) {\n  let rows = ROWS;\n  let cols = COLS;\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (board[i][j].bomb) {\n        continue;\n      }\n\n      if (i > 0 && board[i - 1][j].bomb) {\n        board[i][j].value++;\n      }\n\n      if (i > 0 && j < cols - 1 && board[i - 1][j + 1].bomb) {\n        board[i][j].value++;\n      }\n\n      if (j < cols - 1 && board[i][j + 1].bomb) {\n        board[i][j].value++;\n      }\n\n      if (i < rows - 1 && j < cols - 1 && board[i + 1][j + 1].bomb) {\n        board[i][j].value++;\n      }\n\n      if (i < rows - 1 && board[i + 1][j].bomb) {\n        board[i][j].value++;\n      }\n\n      if (i < rows - 1 && j > 0 && board[i + 1][j - 1].bomb) {\n        board[i][j].value++;\n      }\n\n      if (j > 0 && board[i][j - 1].bomb) {\n        board[i][j].value++;\n      }\n\n      if (i > 0 && j > 0 && board[i - 1][j - 1].bomb) {\n        board[i][j].value++;\n      }\n    }\n  }\n}\n\nfunction randomNum(max) {\n  return Math.floor(Math.random() * (max - 1) + 1);\n}\n\nexport default CreateBoard;\n\nvar _c;\n\n$RefreshReg$(_c, \"CreateBoard\");","map":{"version":3,"names":["ROWS","COLS","MINES","CreateBoard","board","mines","emptySpaces","x","subColumn","y","push","value","fired","flagged","bomb","mineCount","randomNum","findAdjacentBombs","rows","cols","i","j","max","Math","floor","random"],"sources":["/Users/tannerlankford/repos/MinesweeperJS/src/utils/CreateBoard.js"],"sourcesContent":["const ROWS = 8;\nconst COLS = 9;\nconst MINES = 10;\nfunction CreateBoard() {\n    let board = [];\n    let mines = [];\n    // let numMines = 10;\n    // let rows = 8;\n    // let cols = 9;\n    let emptySpaces = (ROWS * COLS) - MINES;\n\n    for (let x = 0; x < ROWS; x++) {\n        let subColumn = [];\n        for (let y = 0; y < COLS; y++) {\n            subColumn.push({\n                value: 0,\n                fired: false,\n                x: x,\n                y: y,\n                flagged: false,\n                bomb: false\n            });\n        }\n        board.push(subColumn);\n    }\n\n    // Randomly assign bombs to the board\n    let mineCount = 0;\n    while (mineCount < MINES) {\n        let x = randomNum(ROWS);\n        let y = randomNum(COLS);\n\n        if (!board[x][y].bomb) {\n            board[x][y].bomb = true;\n            mines.push([x, y]);\n            mineCount++;\n        }\n    }\n    findAdjacentBombs(board);\n\n    return { board, mines, emptySpaces };\n};\n\n// Iterate through cells and count the number of adjacent bombs, incrementing the value of the cell\n    // if any are found\nfunction findAdjacentBombs(board) {\n    let rows = ROWS;\n    let cols = COLS;\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (board[i][j].bomb) {\n                continue;\n            }\n\n            if (i > 0 && board[i - 1][j].bomb) {\n                board[i][j].value++;\n            }\n\n            if (i > 0 && j < cols - 1 && board[i - 1][j + 1].bomb) {\n                board[i][j].value++;\n            }\n\n            if (j < cols - 1 && board[i][j + 1].bomb) {\n                board[i][j].value++;\n            }\n\n            if (i < rows - 1 && j < cols - 1 && board[i + 1][j + 1].bomb) {\n                board[i][j].value++;\n            }\n\n            if (i < rows - 1 && board[i + 1][j].bomb) {\n                board[i][j].value++;\n            }\n\n            if (i < rows - 1 && j > 0 && board[i + 1][j - 1].bomb) {\n                board[i][j].value++;\n            }\n\n            if (j > 0 && board[i][j - 1].bomb) {\n                board[i][j].value++;\n            }\n\n            if (i > 0 && j > 0 && board[i - 1][j - 1].bomb) {\n                board[i][j].value++;\n            }\n        }\n    }\n\n}\n\nfunction randomNum(max) {\n    return Math.floor(Math.random() * (max - 1) + 1);\n}\n\nexport default CreateBoard"],"mappings":"AAAA,MAAMA,IAAI,GAAG,CAAb;AACA,MAAMC,IAAI,GAAG,CAAb;AACA,MAAMC,KAAK,GAAG,EAAd;;AACA,SAASC,WAAT,GAAuB;EACnB,IAAIC,KAAK,GAAG,EAAZ;EACA,IAAIC,KAAK,GAAG,EAAZ,CAFmB,CAGnB;EACA;EACA;;EACA,IAAIC,WAAW,GAAIN,IAAI,GAAGC,IAAR,GAAgBC,KAAlC;;EAEA,KAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,IAApB,EAA0BO,CAAC,EAA3B,EAA+B;IAC3B,IAAIC,SAAS,GAAG,EAAhB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,IAApB,EAA0BQ,CAAC,EAA3B,EAA+B;MAC3BD,SAAS,CAACE,IAAV,CAAe;QACXC,KAAK,EAAE,CADI;QAEXC,KAAK,EAAE,KAFI;QAGXL,CAAC,EAAEA,CAHQ;QAIXE,CAAC,EAAEA,CAJQ;QAKXI,OAAO,EAAE,KALE;QAMXC,IAAI,EAAE;MANK,CAAf;IAQH;;IACDV,KAAK,CAACM,IAAN,CAAWF,SAAX;EACH,CArBkB,CAuBnB;;;EACA,IAAIO,SAAS,GAAG,CAAhB;;EACA,OAAOA,SAAS,GAAGb,KAAnB,EAA0B;IACtB,IAAIK,CAAC,GAAGS,SAAS,CAAChB,IAAD,CAAjB;IACA,IAAIS,CAAC,GAAGO,SAAS,CAACf,IAAD,CAAjB;;IAEA,IAAI,CAACG,KAAK,CAACG,CAAD,CAAL,CAASE,CAAT,EAAYK,IAAjB,EAAuB;MACnBV,KAAK,CAACG,CAAD,CAAL,CAASE,CAAT,EAAYK,IAAZ,GAAmB,IAAnB;MACAT,KAAK,CAACK,IAAN,CAAW,CAACH,CAAD,EAAIE,CAAJ,CAAX;MACAM,SAAS;IACZ;EACJ;;EACDE,iBAAiB,CAACb,KAAD,CAAjB;EAEA,OAAO;IAAEA,KAAF;IAASC,KAAT;IAAgBC;EAAhB,CAAP;AACH;;KAtCQH,W;AAsCR,C,CAED;AACI;;AACJ,SAASc,iBAAT,CAA2Bb,KAA3B,EAAkC;EAC9B,IAAIc,IAAI,GAAGlB,IAAX;EACA,IAAImB,IAAI,GAAGlB,IAAX;;EACA,KAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAApB,EAA0BE,CAAC,EAA3B,EAA+B;IAC3B,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAApB,EAA0BE,CAAC,EAA3B,EAA+B;MAC3B,IAAIjB,KAAK,CAACgB,CAAD,CAAL,CAASC,CAAT,EAAYP,IAAhB,EAAsB;QAClB;MACH;;MAED,IAAIM,CAAC,GAAG,CAAJ,IAAShB,KAAK,CAACgB,CAAC,GAAG,CAAL,CAAL,CAAaC,CAAb,EAAgBP,IAA7B,EAAmC;QAC/BV,KAAK,CAACgB,CAAD,CAAL,CAASC,CAAT,EAAYV,KAAZ;MACH;;MAED,IAAIS,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAGF,IAAI,GAAG,CAApB,IAAyBf,KAAK,CAACgB,CAAC,GAAG,CAAL,CAAL,CAAaC,CAAC,GAAG,CAAjB,EAAoBP,IAAjD,EAAuD;QACnDV,KAAK,CAACgB,CAAD,CAAL,CAASC,CAAT,EAAYV,KAAZ;MACH;;MAED,IAAIU,CAAC,GAAGF,IAAI,GAAG,CAAX,IAAgBf,KAAK,CAACgB,CAAD,CAAL,CAASC,CAAC,GAAG,CAAb,EAAgBP,IAApC,EAA0C;QACtCV,KAAK,CAACgB,CAAD,CAAL,CAASC,CAAT,EAAYV,KAAZ;MACH;;MAED,IAAIS,CAAC,GAAGF,IAAI,GAAG,CAAX,IAAgBG,CAAC,GAAGF,IAAI,GAAG,CAA3B,IAAgCf,KAAK,CAACgB,CAAC,GAAG,CAAL,CAAL,CAAaC,CAAC,GAAG,CAAjB,EAAoBP,IAAxD,EAA8D;QAC1DV,KAAK,CAACgB,CAAD,CAAL,CAASC,CAAT,EAAYV,KAAZ;MACH;;MAED,IAAIS,CAAC,GAAGF,IAAI,GAAG,CAAX,IAAgBd,KAAK,CAACgB,CAAC,GAAG,CAAL,CAAL,CAAaC,CAAb,EAAgBP,IAApC,EAA0C;QACtCV,KAAK,CAACgB,CAAD,CAAL,CAASC,CAAT,EAAYV,KAAZ;MACH;;MAED,IAAIS,CAAC,GAAGF,IAAI,GAAG,CAAX,IAAgBG,CAAC,GAAG,CAApB,IAAyBjB,KAAK,CAACgB,CAAC,GAAG,CAAL,CAAL,CAAaC,CAAC,GAAG,CAAjB,EAAoBP,IAAjD,EAAuD;QACnDV,KAAK,CAACgB,CAAD,CAAL,CAASC,CAAT,EAAYV,KAAZ;MACH;;MAED,IAAIU,CAAC,GAAG,CAAJ,IAASjB,KAAK,CAACgB,CAAD,CAAL,CAASC,CAAC,GAAG,CAAb,EAAgBP,IAA7B,EAAmC;QAC/BV,KAAK,CAACgB,CAAD,CAAL,CAASC,CAAT,EAAYV,KAAZ;MACH;;MAED,IAAIS,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAb,IAAkBjB,KAAK,CAACgB,CAAC,GAAG,CAAL,CAAL,CAAaC,CAAC,GAAG,CAAjB,EAAoBP,IAA1C,EAAgD;QAC5CV,KAAK,CAACgB,CAAD,CAAL,CAASC,CAAT,EAAYV,KAAZ;MACH;IACJ;EACJ;AAEJ;;AAED,SAASK,SAAT,CAAmBM,GAAnB,EAAwB;EACpB,OAAOC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,MAAiBH,GAAG,GAAG,CAAvB,IAA4B,CAAvC,CAAP;AACH;;AAED,eAAenB,WAAf"},"metadata":{},"sourceType":"module"}